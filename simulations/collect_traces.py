from tqdm.auto import tqdm
import estraces
import numpy as np
import scared
import util
import modop



def collect_traces_basemult(N, reduction=None, n=256, q=769, alpha=1, beta1=0, beta2=0,sigma=0, 
                            dtype='int32', const_seed=False, prng_off=False, boolean_mask=False,
                            two_step=False, mult_hw_dtype=None, hw_dtype=None, seed=0):
    if const_seed:
        np.random.seed(seed)

    if hw_dtype == None:
        hw_dtype = util.s2u(dtype)

    if two_step and mult_hw_dtype is None:
        mult_hw_dtype = util.u22u(hw_dtype)

    if reduction is None:
        reduction = modop.Reduction_Q2Q2(q, dtype)

    mult_dtype = util.s22s(dtype)

    samples, cs, ss, s0s, s1s = [], [], [], [], []

    s = np.random.randint(1, q, n, dtype=dtype)
    
    for i in tqdm(range(N)):

        c = np.random.randint(0, q, n, dtype=dtype)
        masks = np.random.randint(0, q, n, dtype=dtype) if not prng_off else np.zeros(n, dtype=dtype)

        cs.append(c)

        
        s0 = (s - masks) % np.uint64(q)
        s1 = masks
        s0s.append(s0)
        s1s.append(s1)
        ss.append(s)

        res0 = c.astype(mult_dtype) * s.astype(mult_dtype)
        res = reduction.reduce(res0)

        if boolean_mask:
            if two_step:
                res01 = np.random.randint(0, q*q, dtype=mult_hw_dtype)
                res00 = res0 ^ res01
            res1 = np.random.randint(0, q, dtype=hw_dtype)
            res0 = res ^ res1
        else:
            res00 = ((c.astype(mult_dtype) * s0.astype(mult_dtype)))
            res01 = ((c.astype(mult_dtype) * s1.astype(mult_dtype)))
            res0 = reduction.reduce(res00)
            res1 = reduction.reduce(res01)
            assert (((res0 + res1) % q) == res % q).all()

        samples_i1 = util.hw(res0, hw_dtype)*alpha + beta1 + np.random.normal(0, sigma, n)
        samples_i2 = util.hw(res1, hw_dtype)*alpha + beta2 + np.random.normal(0, sigma, n)

        if two_step:
            samples_i01 = util.hw(res00, mult_hw_dtype)*alpha + beta1 + np.random.normal(0, sigma, n)
            samples_i02 = util.hw(res01, mult_hw_dtype)*alpha + beta2 + np.random.normal(0, sigma, n)
            samples_i1_concat = np.empty((samples_i1.shape[0]*2))
            samples_i2_concat = np.empty((samples_i2.shape[0]*2))
            samples_i1_concat[1::2] = samples_i1
            samples_i1_concat[::2] = samples_i01
            samples_i2_concat[1::2] = samples_i2
            samples_i2_concat[::2] = samples_i02
            samples_i_concat = np.concatenate(( samples_i1_concat, samples_i2_concat )) 
        else:
            samples_i_concat = np.concatenate(( samples_i1, samples_i2 )) 

        samples.append(samples_i_concat)
        
                                               
    return estraces.read_ths_from_ram(np.array(samples), c=np.array(cs),
                                      s=np.array(ss), s0=np.array(s0s), s1=np.array(s1s))