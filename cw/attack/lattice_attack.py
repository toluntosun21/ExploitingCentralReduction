import os
import time
import numpy as np
import math

from tqdm.auto import tqdm
import rref_modq
import fpylll
import multiprocessing

from itertools import combinations

## helpers ##

def reverse_bits(n, width):    
    b = '{:0{width}b}'.format(n, width=width)
    return int(b[::-1], 2)


class LatticeAttack:

    def __init__(self, n0=64, q=3329, root=17, n=128, filename='f_temp', eta=2):

        self.n = n
        self.n0 = n0
        self.q = q
        self.root = root
        self.filename = filename
        self.verbose = True
        self.eta = eta
        root_inv = pow(root, -1, q)

        logn = round(math.log(n) / math.log(2))
        bit_reverse_table = [reverse_bits(i, logn) for i in range(n)]

        self.ntt_mat = np.zeros((n,n),dtype='uint16')
        for i in range(n):
            for j in range(n): #root**(2*bit_reverse_table[i] + 1)  -> root**5i
                self.ntt_mat[i,j] = pow(root, (2*bit_reverse_table[i] + 1)*j, q)

        self.ntt_mat_inv = np.zeros((n,n), dtype='uint16')
        inv2 = pow(n, -1, q)
        for i in range(n):
            for j in range(n):
                self.ntt_mat_inv[j,i] = (pow(root_inv, (2*bit_reverse_table[i] + 1)*j, q) * inv2) % q

        assert (((np.matmul(self.ntt_mat_inv.astype('uint64'), self.ntt_mat.astype('uint64')) % q) == np.identity(n, dtype = 'uint64')).all())

        self.n1 = n//n0

        self.ntt_mat_n0 = np.zeros((n,n),dtype='uint16')
        for k in range(self.n1):
            for i in range(0, n, self.n1):
                for j in range(0, n, self.n1):
                    self.ntt_mat_n0[i + k,j + k] = (pow(root,(2*bit_reverse_table[i] + 1) * (j), q)) % q
            

        self.ntt_mat_inv_n0 = np.zeros((n,n),dtype='uint16')
        inv2 = pow(n0,-1,q)
        for k in range(self.n1):
            for i in range(0, n, self.n1):
                for j in range(0, n, self.n1):
                    self.ntt_mat_inv_n0[j + k,i + k] = (pow(root_inv,(2*bit_reverse_table[i] + 1) * (j), q)  * inv2) % q

        t1 = (np.matmul(self.ntt_mat_inv_n0.astype('uint64'),self.ntt_mat_n0.astype('uint64')) % q)
        t2 = (np.matmul(self.ntt_mat_n0.astype('uint64'),self.ntt_mat_inv_n0.astype('uint64')) % q)
        assert (t1 == t2).all()
        assert ((t1 == np.identity(n, dtype = 'uint64')).all())

        self.ntt_mat_inv_n1 = np.matmul(self.ntt_mat_n0.astype('uint64'),self.ntt_mat_inv.astype('uint64')) % q
        assert (((np.matmul(self.ntt_mat_inv_n0.astype('uint64'),self.ntt_mat_inv_n1.astype('uint64')) % q)) == self.ntt_mat_inv).all()


    def predict_core(self, f_ntt, A, offset=0):

        assert f_ntt.shape[0] == self.n0
        assert offset < self.n1

        B = [] # unknown part of f_ntt
        for i in range(self.n0):
            if i not in A:
                B.append(i)

        f_ntt_A = f_ntt[A]
        M_A = self.ntt_mat_inv_n0[offset::self.n1,offset::self.n1][:,A]
        M_B = self.q - self.ntt_mat_inv_n0[offset::self.n1,offset::self.n1][:,B]
        t = (np.matmul(M_A.astype('uint64'), f_ntt_A.astype('uint64')) % self.q)
        
        M_B_t = np.transpose(M_B)
        M_B_t_c = rref_modq.rref_modq(M_B_t.astype('int32'), self.q)
        
        B_BDD = np.zeros((self.n0, self.n0),dtype='uint16')
        B_BDD[:self.n0 - len(A)] = M_B_t_c
        B_BDD[self.n0 - len(A):, self.n0 - len(A):] = self.q*np.identity(len(A), dtype = 'uint16')
        
        B_KAN = np.zeros((self.n0 + 1, self.n0 + 1),dtype='uint16')
        B_KAN[:self.n0, :self.n0] = B_BDD
        B_KAN[self.n0, :self.n0] = np.transpose(t)
        B_KAN[self.n0, self.n0] = 1

        A_F = fpylll.IntegerMatrix.from_matrix(B_KAN.tolist())
        flags = fpylll.BKZ.GH_BND|fpylll.BKZ.AUTO_ABORT#|BKZ.VERBOSE#|BKZ.MAX_LOOPS
        par = fpylll.BKZ.Param(50, strategies = fpylll.BKZ.DEFAULT_STRATEGY, max_loops = 0, flags = flags)
        A_F = fpylll.BKZ.reduction(A_F, o=par)
        f_ = np.array([A_F[0][i] for i in range(self.n0)], dtype='int16')
        return f_

    def predict(self, f_ntt, A, write_res=False):
        fpylll.FPLLL.set_threads(16)

        f = np.zeros(self.n, dtype='int16')
        f_ntt_ = (np.matmul(self.ntt_mat_inv_n1.astype('int64'), f_ntt) % self.q)
        for offset in range(self.n1):
            f[offset::self.n1] = self.predict_core(f_ntt_[offset::self.n1], A, offset)
        if write_res:
            np.save(self.filename, f)
        return f


    def predict_scores(self, f_ntt, scores, K, eta, max_L=None):

        assert len(scores) == self.n
        assert K <= self.n0

        if max_L is None:
            max_L = self.n0
        else:
            assert max_L <= self.n0
            assert max_L >= K

        scores_combined = scores[::self.n1]
        for offset in range(1, self.n1):
            scores_combined *=  scores[offset::self.n1]


        coeffs_sorted = scores_combined.argsort()[::-1]
        ctr = 0
        for L in range(K, max_L + 1):
            combs = list(combinations(coeffs_sorted[:L], K))[math.comb(L-1, K):]
            for A in combs:
                if self.verbose:
                    print(f'(iter-{ctr})  A: {list(A)}')
                f = self.predict(f_ntt, list(A), False)
                if np.abs(f).max() <= eta:
                    self.A = list(A)
                    return f
                else:
                    ctr += 1